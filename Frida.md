<div align='center'>

# **Frida Overview**

</div>

## **Table of Content**

- [**I. What is Frida?**](#i-what-is-frida)
- [**II. Installation for Android device**](#ii-installation-for-android-device)
- [**III. Mode of operation**](#iii-mode-of-operation)
- [**IV. Adding `frida-gadget` to an Android application**](#iv-adding-frida-gadget-to-an-android-application)
- [**V. How Frida work**](#v-how-frida-work)
- [**VI. Frida tools**](#vi-frida-tools)
- [**VII. Javascript API**](#vii-javascript-api)
- [**VIII. Bypassing root and emulator detection on a real financial app**](#viii-bypassing-root-and-emulator-detection-on-a-real-financial-app)
- [**IX. Bypassing SSL Pinning on a real financial app**](#ix-bypassing-ssl-pinning-on-a-real-financial-app)

## **I. What is Frida?**

Frida is a dynamic code instrumentation toolkit. It lets you inject snippets of JavaScript or your own library into native apps on Windows, macOS, Linux, iOS, Android, and QNX. It can be used to inspect and modify the behavior of apps in real time, and to explore and exploit software vulnerabilities.

## **II. Installation for Android device**

**Frida Client**

```zsh
python -m pip install frida-tools
```
![](./imgs/Frida/1.png)

![](./imgs/Frida/2.png)

**Frida Server**

Download the Frida server binary from [here](https://github.com/frida/frida/releases)

Extract the xz file to get the binary

Send the binary to the android emulator

![](./imgs/Frida/3.png)

Start the Frida server

![](./imgs/Frida/4.png)

Verify that the Frida server is running

![](./imgs/Frida/5.png)

## **III. Mode of operation**

Frida provides dynamic instrumentation through its powerful instrumentation core Gum, which is written in C. With just a few lines of C you can run a piece of JavaScript inside a runtime that has full access to Gum’s APIs, allowing you to hook functions, enumerate loaded libraries, their imported and exported functions, read and write memory, scan memory for patterns, etc.

### **1.  Injection**

The `frida-server` is runned on IOS and Android devices. It is a a daemon that exposes `frida-core` over TCP, listening on localhost:27042

The `frida-core` acts a logistics layer that packages up GumJS into a shared library that it injects into existing software, and provides a two-way communication channel for talking to your scripts, if needed, and later unload them

### **2.  Embedded**

We have `Frida-gadget`, a shared library that you’re supposed to embed inside the program that you want to instrument.

By simply loading the library it will allow you to interact with it remotely, using existing Frida-based tools like frida-trace

### **3.  Preloaded**

The `frida-server` can be ultimately preloaded into a process using dynamic linker, so that it is automatically started when the process is launched.

## **IV. Adding `frida-gadget` to an Android application**

Target: [InsecureBankv2](https://github.com/dineshshetty/Android-InsecureBankv2)

Use `apktool` to decompile the apk file

```zsh
apktool d .\InsecureBankv2.apk
```

![](./imgs/Frida/14.png)

Download the Frida-gadget binary from [here](https://github.com/frida/frida/releases). Add that into the APK's/lib folder

```zsh
cp .\frida-gadget-16.0.14-android-x86_64.so .\InsecureBankv2\lib\x86_64\libfrida-gadget.so
```

Inject a `System.loadLibrary("frida-gadget")` call into the bytecode of the app. One way is to add the following smali code in a suitable function . A "suitable place" could be a constructor of a main activity right above return statement

```smali
const-string v0, "frida-gadget"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```

![](./imgs/Frida/15.png)

Add the Internet permission to the manifest if it’s not there already, so that Frida gadget can open a socket

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

Build the patched APK

```zsh
apktool b .\InsecureBankv2
```

![](./imgs/Frida/16.png)

Sign the patched APK using your own keys

```zsh
keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000
```
```zsh
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore .\InsecureBankv2\dist\InsecureBankv2.apk alias_name
```

![](./imgs/Frida/18.png)

![](./imgs/Frida/19.png)

Install the patched APK to a device.

**Using frida gadget**

When you next start the application you are going to see an empty screen: The injected libfrida-gadget.so library has opened a tcp socket and waits for a connection from frida.

The message: `Frida   : Listening on 127.0.0.1 TCP port 27042` will appear in the logcat

![](./imgs/Frida/20.png)

Running nestat on the device confirms the listening socket:

![](./imgs/Frida/21.png)

Use `frida -U Gadget` to connect to the listening socket (this will make the app running)

![](./imgs/Frida/22.png)

## **V. How Frida work**

- First User have to create an file in which patching method written like Accessing any method value, or changing return value

- The patched method is sent from the computer of the User to the agent frida (installed on android device)

- The agent being inserted in the application on the mobile

- And there, the patch (in js) is compiled and used to patch application

    ![](./imgs/Frida/23.png)

While the application is running

- The ART loads the app’s .oat file to run it and the .so containing FridaDroid + patch is started.
- In the .so, FridaDroid hook ART functions
- Get the references of the target method using the hooks obtained in (1).
- Compile the patch and modify the reference to the target method with the binaries obtained at the end of the compilation.
- The application continues to run

![](./imgs/Frida/24.png)

## **VI. Frida tools**

**Frida CLI:**  REPL interface, a tool aimed at rapid prototyping and easy debugging

![](./imgs/Frida/26.png)

**frida-ps:** This is a command-line tool for listing processes, which is very useful when interacting with a remote system

- **frida-ps -U:** List processes running on the USB-connected device

![](./imgs/Frida/27.png)

- **frida-ps -Ua:** List running application

![](./imgs/Frida/28.png)

- **frida-ps -Uai:** List installed application

![](./imgs/Frida/29.png)

- **frida-discover:** frida-discover is a tool for discovering internal functions in a program 

![](./imgs/Frida/25.png)

**frida-trace** : frida-trace is a tool for dynamically Monitoring/tracing Method calls. It is useful for debugging method calls on every event in mobile application. Syntax:

```zsh
frida-trace -j "class!method" -U -f <application_package_name>
```

![](./imgs/Frida/30.png)

**frida-ls-devices:** This is a command-line tool for listing attached devices, which is very useful when interacting with multiple devices.

![](./imgs/Frida/31.png)

**frida-kill:** This is a command-line tool for killing processes

![](./imgs/Frida/32.png)

## **VII. Javascript API**

- **Java.available:** A boolean specifying whether the current process has the a Java VM loaded

- **Java.androidVersion:** A string specifying which version of Android we’re running on

- **Java.enumerateLoadedClasses(callbacks)**: enumerate classes loaded right now, where `callbacks` is an object specifying:

    - **onMatch(name, handle):** called for each loaded class with name that may be passed to `use()` to get a JavaScript wrapper

    - **onComplete():** called when all classes have been enumerated

[Example](./scripts/frida/enumerate_class.js)

![](./imgs/Frida/33.png)

- **Java.enumerateClassLoaders(callbacks):** enumerate class loaders present in the Java VM, where callbacks is an object specifying:

    - **onMatch(loader):** called for each class loader with loader, a wrapper for the specific java.lang.ClassLoader.

    - **onComplete():** called when all class loaders have been enumerated.

You may pass such a loader to `Java.ClassFactory.get()` to be able to .`use()` classes on the specified class loader.

[Example](./scripts/frida/enumerate_class_loader.js)

![](./imgs/Frida/34.png)

- **Java.enumerateMethods(query):** Enumerate methods matching query, specified as 'class!method'

![](./imgs/Frida/35.png)

![](./imgs/Frida/36.png)

- **Java.scheduleOnMainThread(function):** The callback function is executed on the VM main thread (UI thread). Operating UI elements in Android requires code execution in the main thread, and scheduleOnMainThreadits role is to execute functions in the main thread

- **Java.perform(function):** ensure that the current thread is attached to the VM and call function. and the function is called. This function calls `VM::AttachCurrentThread` internally, then executes the Javascript script in the function callback function to operate the Java runtime, and finally uses `VM::DetachCurrentThread` to release resources

- **Java.use(className):** dynamically get a JavaScript wrapper for className that you can instantiate objects from by calling `$new()` on it to invoke a constructor

    Uses the app’s class loader by default, but you may customize this by assigning a different loader instance to Java.classFactory.loader

- **Java.openClassFile(filePath):** open the .dex file at filePath, returning an object with the following methods:

    - **load():** load the contained classes into the VM.

    - **getClassNames():** obtain an array of available class names.

- **Java.choose(className, callbacks):** Scan Java heap in memory and enumerate Java object (className) instances, where callbacks is an object specifying:

    - **onMatch(instance):** called with each live instance found with a ready-to-use instance just as if you would have called `Java.cast()` with a raw handle to this particular instance.
    This function may return the string stop to cancel the enumeration early.

    - **onComplete():** called when all instances have been enumerated

- **Java.retain(obj):** duplicates the JavaScript wrapper obj for later use outside replacement method.

    ```javascript
    Java.perform(() => {
        const Activity = Java.use('android.app.Activity');
        let lastActivity = null;
        Activity.onResume.implementation = function () {
            lastActivity = Java.retain(this);
            this.onResume();
        };
    });
    ```

- **Java.cast(handle, klass):** Create a JavaScript wrapper given the existing instance at the handle of given class klass as returned from `Java.use()`

- **Java.array(type, elements):** creates a Java array with elements of the specified type, from a JavaScript array elements

    ```javascript
    const values = Java.array('int', [ 1003, 1005, 1007 ]);
    const JString = Java.use('java.lang.String');
    const str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ]));
    ```
- **Java.isMainThread():** Check the Programm executing in main thread or not.
When a Java program starts up, one thread begins running immediately. This is usually called the main thread of our program

- **Java.registerClass(spec):** create a new Java class and return a wrapper for it, where spec is an object containing:

    - **name:** String specifying the name of the class.
    - **superClass:** (optional) Super-class. Omit to inherit from `java.lang.Object`.
    - **implements:** (optional) Array of interfaces implemented by this class.
    - **fields:** (optional) Object specifying the name and type of each field to expose.
    - **methods:** (optional) Object specifying methods to implement

- **Java.deoptimizeEverything():** forces the VM to execute everything with its interpreter.

- **Java.deoptimizeBootImage():** similar to `Java.deoptimizeEverything()` but only deoptimizes boot image code

- **Java.vm:** object with the following methods:

    - **perform(fn):** ensures that the current thread is attached to the VM and calls fn. (This isn’t necessary in callbacks from Java.)

    - **getEnv():** gets a wrapper for the current thread’s JNIEnv. Throws an exception if the current thread is not attached to the VM.

    - **tryGetEnv():** tries to get a wrapper for the current thread’s JNIEnv. Returns null if the current thread is not attached to the VM.

- **Java.classFactory:** the default class factory used to implement e.g. Java.use(). Uses the application’s main class loader

- **Java.ClassFactory:** class with the following properties:

    **get(classLoader):** Gets the class factory instance for a given class loader..

    **loader:** read-only property providing a wrapper for the class loader currently being used. For the default class factory this is updated by the first call to Java.perform().

    **cacheDir:** string containing path to cache directory currently being used. For the default class factory this is updated by the first call to `Java.perform()`.

    **tempFileNaming:** object specifying naming convention to use for temporary files. Defaults to { prefix: 'frida', suffix: 'dat' }.

    **use(className):** like `Java.use()` but for a specific class loader.

    **openClassFile(filePath):** like Java.`openClassFile()` but for a specific class loader.

    **choose(className, callbacks):** like `Java.choose()` but for a specific class loader.

    **retain(obj):** like `Java.retain()` but for a specific class loader.

    **cast(handle, klass):** like `Java.cast()` but for a specific class loader.

    **array(type, elements):** like `Java.array()` but for a specific class loader.

    **registerClass(spec):** like `Java.registerClass()` but for a specific class loader.

## **VIII. Bypassing root and emulator detection on a real financial app**

Target: [9pay](https://play.google.com/store/apps/details?id=vn.ninepay.ewallet&hl=vi&gl=US)

Download the app and install it on your device. Then, get the apk file

![](./imgs/Frida/37.png)

Use jadx-gui to decompile the apk file. We will try to find the root detection method in the app

`isRooted()` method in `com.scottyab.rootbeer.RootBeer`

![](./imgs/Frida/38.png)

`isRootedWithBusyBoxCheck()` method in `com.scottyab.rootbeer.RootBeer`

![](./imgs/Frida/39.png)

`isRooted()` and `isEmulator()` method in `com.google.firebase.crashlytics.internal.common.CommonUtils`

![](./imgs/Frida/40.png)

`checkRooted()` method in `com.xamdesign.safe_device.Rooted.LessThan23`

![](./imgs/Frida/41.png)

`checkRooted()` method in `com.xamdesign.safe_device.Rooted.GreaterThan23`

![](./imgs/Frida/42.png)

`isDeviceRooted$crashguard_release()` method in `co.hyperverge.crashguard.utils.RootChecker`

![](./imgs/Frida/44.png)

`b()` method in `co.hyperverge.hypersnapsdk.utils.j`

![](./imgs/Frida/43.png)

`isEmulator()` method in `com.xamdesign.safe_device.Emulator.EmulatorCheck`

![](./imgs/Frida/44.png)

`isEmulator()` method in `dev.fluttercommunity.plus.device_info.MethodCallHandlerImpl`

![](./imgs/Frida/45.png)

We will hook each method to bypass the root detection and change the return value to `false`:

```javascript
    var clRootBeer = Java.use("com.scottyab.rootbeer.RootBeer");
    clRootBeer.isRooted.implementation = function () {
        console.log("Hooked isRooted");
        return false;
    }
```

Full script is [here](./scripts/frida/root_and_emulator_bypass.js):

**Test**

Before hooking:

![](./imgs/Frida/46.png)

After hooking:

![](./imgs/Frida/47.png)

## **IX. Bypassing SSL Pinning on a real financial app**

Target: [Paypal](https://play.google.com/store/apps/details?id=com.paypal.android.p2pmobile&hl=vi&gl=US)

Get Burp Suite's certificate and push it to the device:

- Go to http://burp and download the certificate

- Push the certificate to the device:

    ```bash
    adb push cacert.der /data/local/tmp/cert-der.crt
    ```
- Configure proxy on Burp Suite and Emulator:

    **Burp Suite**

    The Address of the emulator: 192.168.137.101:5555

    ![](./imgs/TestCurl/2.png)

    Add a new proxy listener

    ![](./imgs/TestCurl/3.png)

    **Emulator**

    Configure the proxy

    ![](./imgs/TestCurl/4.png)

When we open the app, we can see that the app is using SSL Pinning to prevent the Burp Suite from intercepting the traffic

![](./imgs/Frida/48.png)

We will use [this script](./scripts/frida/sslpinning.js) from https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/ to bypass SSL pinning.

**Test:**

![](./imgs/Frida/49.png)

![](./imgs/Frida/50.png)

![](./imgs/Frida/51.png)